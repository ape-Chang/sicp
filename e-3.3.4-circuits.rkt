#lang racket
(require compatibility/mlist)

(define (make-wire)
  (let ((signal-value 0)
        (procedures '()))

    (define (set-signal! new-value)
      (if (= signal-value new-value)
          'done
          (begin (set! signal-value new-value)
                 (call-each procedures))))

    (define (add-action! proc)
      (set! procedures (cons proc procedures))
      (proc))

    (define (call-each procedures)
      (if (null? procedures)
          'done
          (begin
            ((car procedures))
            (call-each (cdr procedures)))))

    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-signal!)
            ((eq? m 'add-action!) add-action!)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))

(define (get-signal wire) (wire 'get-signal))
(define (set-signal! wire new-value) ((wire 'set-signal!) new-value))
(define (add-action! wire proc) ((wire 'add-action!) proc))
;;
(define (make-time-segment time queue) (mcons time queue))
(define (segment-time s) (mcar s))
(define (segment-queue s) (mcdr s))
;;
(define (make-agenda) (mlist 0))
(define (current-time agenda) (mcar agenda))
(define (set-current-time! agenda time) (set-mcar! agenda time))
(define (segments agenda) (mcdr agenda))
(define (set-segments! agenda segments) (set-mcdr! agenda segments))
(define (first-segment agenda) (mcar (segments agenda)))
(define (rest-segments agenda) (mcdr (segments agenda)))
(define (empty-agenda? agenda) (null? (segments agenda)))
;;
(define (make-queue) (mcons '() '()))
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (mcar (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (mcons item '())))
    (if (empty-queue? queue)
        (begin
          (set-front-ptr! queue new-pair)
          (set-rear-ptr! queue new-pair)
          queue)
        (begin
          (set-mcdr! (rear-ptr queue) new-pair)
          (set-rear-ptr! queue new-pair)
          queue))))
(define (delete-queue! queue)
  (if (empty-queue? queue)
      (error "DELETE! called with an empty queue" queue)
      (set-front-ptr! queue (mcdr (front-ptr queue)))))
(define (print-queue queue)
  (mlist->list (front-ptr queue)))
;; 
(define (front-ptr queue) (mcar queue))
(define (rear-ptr queue) (mcdr queue))
(define (set-front-ptr! queue item) (set-mcar! queue item))
(define (set-rear-ptr! queue item) (set-mcdr! queue item))
;;
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (mcar segments)))))

  (define (make-new-time-segment time action)
    (let ((queue (make-queue)))
      (insert-queue! queue action)
      (make-time-segment time queue)))
  
  (define (add-to-segments! segments)
    (let ((first (mcar segments))
          (rest (mcdr segments)))
      (if (= time (segment-time first))
          (insert-queue! (segment-queue first) action)
          (if (belongs-before? rest)
              (set-mcdr! segments (mcons (make-new-time-segment time action) rest))
              (add-to-segments! rest)))))

  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments! agenda (mcons (make-new-time-segment time action)
                                     segments))
        (add-to-segments! segments))))

(define (remove-first-agenda-item! agenda)
  (let ((queue (segment-queue (first-segment agenda))))
    (delete-queue! queue)
    (if (empty-queue? queue)
        (set-segments! agenda (rest-segments agenda))
        '())))

(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first (first-segment agenda)))
        (set-current-time! agenda (segment-time first))
        (front-queue (segment-queue first)))))
;;
(define the-agenda (make-agenda))
(define invert-delay 1)
;;
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))

(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
;;
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))
(define (logical-and s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
        ((or (and (= s1 1) (= s2 0))
             (and (= s1 0) (= s2 1))
             (and (= s1 0) (= s2 0))) 0)
        (else (error "Invalid signals" s1 s2))))
(define (logical-or s1 s2)
  (cond ((or (and (= s1 1) (= s2 1))
             (and (= s1 1) (= s2 0))
             (and (= s1 0) (= s2 1)))
         1)
        ((and (= s1 0) (= s2 0)) 0)
        (else (error "Invalid signals" s1 s2))))
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay invert-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)